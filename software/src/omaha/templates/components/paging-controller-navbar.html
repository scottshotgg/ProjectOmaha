<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="/bower_components/iron-flex-layout/classes/iron-flex-layout.html">
<link rel="import" href="/bower_components/iron-icons/image-icons.html">
<link rel="import" href="/bower_components/iron-icons/av-icons.html">
<link rel="import" href="/bower_components/paper-card/paper-card.html">
<link rel="import" href="/bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/bower_components/paper-slider/paper-slider.html">
<link rel="import" href="/bower_components/paper-drawer/paper-drawer.html">
<link rel="import" href="/bower_components/paper-item/paper-item.html">
<link rel="import" href="/bower_components/paper-toast/paper-toast.html">
<link rel="import" href="/bower_components/paper-button/paper-button.html">
<link rel="import" href="/bower_components/paper-styles/paper-styles.html">
<link rel="import" href="/bower_components/neon-animation/neon-animation.html">
<link rel="import" href="/bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="/components/speaker-icon.html">
<link rel="import" href="/components/omaha-app.html">
<link rel="import" href="/components/zones/zone-assigner.html">
<script src="jquery-ui-1.11.4.js" type="text/jscript"></script>

<dom-module id="paging-controller-navbar" class="layout horizontal">
  <template>
    <style>
      :host {
        display: block;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      paper-card {
        padding: 10px;
        width: 100%;
        height: 100%;   /* This was 100%, cahnge back if needed */
        text-align: center;
      }

      #zoneBtn {
        background-color: #4285f4;
        color: #fff;
        margin-top: 5px;
        width: 100%;
      }
      
      #pageContainer {
        text-align: center;
        height: 100%;
      }

      #zoneMap {
        height: 100%;
      }

      #mainContainer {
        overflow-y: hidden;
      }

      #mainContainer.paper-header-panel {
        position: relative;
        overflow-y: scroll;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        height: 100%;
      }

      .paper-card .card-content {
        padding: 0px;
        height: 200%;
      }
      
      paper-button {
        background-color: #3f51b5;
        color: #fff;
      }

      paper-input /deep/ #input {
        margin-top: 0px;
        text-align: center;
      }

      paper-item::shadow .button-content {
        padding: 0;
        width: 100%;
        text-align: center;
      }

      .pagingZoneStyle {
        background: rgba(63, 81, 181, .1); 
        border-style: solid; 
        border-radius: 5px; 
        border-width: 1px; 
        border-color: #3f51b5; 
        margin: 5px; 
      }

    </style>
    <div id="pagingMapContainer" style="width: 75%; height: 100%; float: left;"></div>
    <div id="selectedSpeakers" style="border-left: 2px solid #3f51b5; margin-left: 75%; width: 25%; height: 90%;">
      <body class="fullbleed layout vertical">
        <paper-header-panel mode="waterfall" style="overflow-y: hidden; background-color: #fff">
          <paper-toolbar>
            <div style="text-align: center; width: 100%;"><font>Zones and Speakers</font><h6 style="margin: 0px; text-align: center;">make an escape event key that will clear this</h6><h6 style="margin: 0px; text-align: center;"></div>
          </paper-toolbar>
          <div id="dropShadow" class="style-scope paper-header-panel has-shadow"></div>
          <div id="pagingSpeakerHolder">
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">Marketing</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">Lobby</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">Conference Room 1</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">Andy</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">Bruce</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">Danny</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>
             <paper-item center-justified flex class="pagingZoneStyle"><font style="text-align: center; width: 100%;">"And Another One"</font></paper-item>

          </div>
        </paper-header-panel>
      </body>
    </div>

    <div id="buttonHolder" style="border-left: 2px solid #3f51b5; border-top: 2px solid #3f51b5; background-color: #fff; margin-left: 75%; width: 25%; height: 9.8%;">
      <paper-card class="layout horizontal">
        <div class="card-content">
          <paper-button on-click="_dial" style="margin-left: 95%;">Dial</paper-button></div>
          <!-- <paper-dropdown-menu id="zoneCallingMenu" no-label-float label="Zone:" style="margin-top: 4%; margin-left: 8%;"> -->
          <paper-listbox id="callingListbox" attr-for-selected="value" selected="{{selection}}" class="dropdown-content" value="0">
            <!--<template if="{{this.speaker.Response}}">
              <paper-dropdown-menu selected="{{selected}}">
                <template repeat="{{label in this.speaker.PresetNames}}">
                  <paper-item value="{{i}}" label="{{label}}"></paper-item>
                </template>
              </paper-dropdown-menu>  
            </template>-->      <!-- this needs to be populated and lifted up -->
          </paper-listbox>
        </paper-dropdown-menu>
      </paper-card>
    </div>
                    <!-- A rougue missing tag, why is this here? -->
    <paper-toast id="toast"></span>Zone Created!</paper-toast>
    <paper-card id="popup">
      <div>Current Zone: <span><b>{{selected.zone.name}}</b></span></div>
      <div><paper-button id="zoneBtn" on-click="_assignZone">assign zone</paper-button></div>
    </paper-card>
    <paper-dialog id="dialog">
      <zone-assigner on-zoneupdated="_refreshSpeaker" id="zoneAssigner" speaker="{{selected}}" zones="{{zones}}"></zone-assigner>
    </paper-dialog>



    <paper-dialog id="zoneDialog" heading="this is a title" entry-animation="scale-up-animation" exit-animation="fade-out-animation" modal="true">
      <h1 style="text-align: center;">Calling selected...</h1>
      <!-- <div style="text-align: center;">Enter a name for the new zone below</div> -->
      <!-- <div class="message">{{err}}</font></div> -->
      <!-- <paper-input id="popupInput" label="" placeholder="Enter Name for Zone" text-align="center"></paper-input> -->
      <div class="buttons" class="layout horizontal">
      <!-- <paper-button ondialog-confirm on-click="_acceptPressed">Create</paper-button> -->
      <paper-button center-justified flex dialog-dismiss on-click style="margin: 0.5em 4.5em .5em 0em;" ="_cancelPressed">Cancel</paper-button>
    </div>



    <!-- <help-panel></help-panel> -->
  </template>

  <script>

  var map;
  var features;
  var mapController;
  var idIterator = 0;
  var currentSpeakers = [];


  function pulsateCircle(id, coordinates) {
    var elem = document.createElement('div');
    elem.setAttribute('class', 'gps_ring');

    //coordinates[0] += 2;
    //coordinates[1] -= 2;

    return new ol.Overlay({
      id: id,
      element: elem,
      position: coordinates,
      positioning: 'center-center'
    });
  }

  function findZoneIndex(zoneName) {
    console.log(zoneName);
    for(var i = 0; i < zones.length; i++) {
      if(zones[i].name === zoneName) {        
        for(var k = 0; k < zones[i].speakers.length; k++) {
          currentSpeakers[k] = zones[i].speakers[k].id;
        }
        console.log("found a name");
        return i;
      }
    }
    for(var i = 0; i < pagingZones.length; i++) {
      if(pagingZones[i].name === zoneName) {
        console.log(pagingZones[i]);
        for(var k = 0; k < pagingZones[i].speakers.length; k++) {
          currentSpeakers[k] = pagingZones[i].speakers[k].id;
        }
        return i;
      }
    }
    var zoneNameInt = parseInt(zoneName);
    for(var i = 0; i < zones[0].speakers.length; i++) {
      if(zones[0].speakers[i].id == zoneNameInt) {
        currentSpeakers = [];
        currentSpeakers[0] = zones[0].speakers[i].id;
        return i;
      }
    }
  }

  // the animations need to be synchronized

  function updateViewForSelectedSpeakers(elem) {
    console.log(elem.id);
    console.log(features);
    console.log(map.a);
    var overlays = mapController.map.getOverlays();
    console.log(overlays);

    // when adding to the view, we can show that the speakers that have been selected are already all in the selected speakers
    console.log(elem);
    var zoneIndex = findZoneIndex(elem.id);
    console.log(typeof currentSpeakers);
    console.log(currentSpeakers, currentSpeakers.length);
    console.log(zoneIndex);
    var zoneOverlayArray = [];
    console.log(elem.id);
    if(displayedZones[elem.id] === undefined) {
      // change the styling to reflect the view
      elem.style.background = "rgba(63, 81, 181, .25)";

      for(var i = 0; i < currentSpeakers.length; i++) {        // just do this for now
        //console.log("current speakers", currentSpeakers);
        var tempOverlay = pulsateCircle(i, features[currentSpeakers[i] - 1].getGeometry().getCoordinates());
        tempOverlay.id = idIterator;
        mapController.map.addOverlay(tempOverlay);
        zoneOverlayArray.push(tempOverlay.id);
        idIterator++;
      }
      displayedZones[elem.id] = zoneOverlayArray;
      mapController.map.updateSize();
    }
    else {
      // change the styling to reflect the view
      elem.style.background = "rgba(63, 81, 181, .1)";

      //var overlays = mapController.map.getOverlays().clear();     // works to clear everything, use it later for the restart
      var overlays = mapController.map.getOverlays();
      console.log(overlays);
      //var overlaysCopy = overlays.a.slice();
      //var overlayLength = overlaysCopy.length;
      console.log(overlays.a.length);

      console.log(displayedZones[elem.id]);
      //for(var j = displayedZones[zones[zoneIndex].name].length - 1; j > 0; j--) {        // just do this for now       shift this down instead of up
      for(var j = displayedZones[elem.id].length - 1; j >= 0; j--) {
        var elementPos = overlays.a.map(function(x) { return x.id; }).indexOf(displayedZones[elem.id][j]);

        var objectFound = overlays.a[elementPos];
        console.log(objectFound);
        mapController.map.removeOverlay(objectFound);
      }
      //console.log(overlays.a.length, overlayLength);
        
      //console.log(mapController.map.removeOverlay(pulsateCircle(j, features[zones[zoneIndex].speakers[j].id - 1].getGeometry().getCoordinates())));

     // / displayedZones[zones[zoneIndex].name] = undefined;
      mapController.map.updateSize();
      displayedZones[elem.id] = undefined;
      currentSpeakers = [];
    }
    console.log(displayedZones);

    console.log(displayedZones);
  }

  (function() {
    $(".pagingZoneStyle").each(function(i) {
      console.log(i);
    });
  })();


  // the name needs to be limited to 50 characters

    var totalInfo = [];
    
    Polymer({
      is: 'paging-controller-navbar',

      behaviors: [
        Polymer.NeonAnimatableBehavior
      ],

      properties: {
        animationConfig: {
          value: function() {
            return {
              'entry': {
                  name: 'fade-in-animation',
                  node: this
                },
              'exit': {
                // provided by neon-animation-animations/fade-out-animation.html
                name: 'slide-left-animation',
                node: this
              }
            }
          }
        }
      },

      _acceptPressed: function(e) {
        this.$.zoneDialog.toggle();
        this.$.toast.show();
        console.log("_acceptPressed", totalInfo);
        var name = this.$.popupInput.value.valueOf().replace("\n", "").replace("\t", "");

        // this is where we strip out the undefineds

        this.$.createPagingZoneAjax.body = {
          // make sure that this isn't empty, do the disable button thing
          // send the name with this too dummy
          "name":     name,
          "speakers": totalInfo   // stripem out, maybe we can just takem out when we show them in list
        }

        totalInfo = [];
        document.getElementById("pagingSpeakerHolder").innerHTML = "";

        console.log("createPagingZoneAjax:", createPagingZoneAjax.body);
        this.$.createPagingZoneAjax.generateRequest();
      },

      _cancelPressed: function(e) {
      },

      _dial: function(e) {
        this.$.zoneDialog.toggle();
      },
      
      _refreshSpeaker: function(e) {
        var speakerId = e.detail.speakerId;
        this.featureMap[speakerId].changed();
      },
      
      _assignZone: function() {
        this._hideOverlay();
        this.$.dialog.open();
      },
      
      _hideOverlay: function() {
        this.overlay.setPosition(undefined);
      },

      renderMap: function() {
        mapController = this;
        mapController.featureMap = {};
        var container = mapController.$.popup;
        var overlay = new ol.Overlay(/** @type {olx.OverlayOptions} */ ({
          element: container,
          autoPan: true,
          autoPanAnimation: {
            duration: 250
          }
        }));
      
        mapController.overlay = overlay;
        
        // Map views always need a projection.  Here we just want to map image
        // coordinates directly to map coordinates, so we create a projection that uses
        // the image 4 in pixels.
        var extent = [0, 0, 2200, 1700];
        var projection = new ol.proj.Projection({
          code: 'pixel',
          units: 'pixels',
          extent: extent
        });

        var locations = this.controllers;
        features = new Array(locations.length);
        for(var i = 0; i < features.length; i++) {
            var coordinates = [locations[i].x, 1700-locations[i].y];
            features[i] = new ol.Feature({
              geometry: new ol.geom.Point(coordinates),
              speaker: locations[i]
            });
            mapController.featureMap[locations[i].id] = features[i]
        }

        var vectorSource = new ol.source.Vector({
            features: features
        });

        var style = {}

       var allColors = [
          /*'#795548',
          '#ff5722',
          '#ff9800',
          '#ffc107',
          //'--paper-yellow-500', this is kinda hard to see
          '#cddc39',
          '#8bc34a',
          '#009688',
          '#00bcd4',
          '#03a9f4',
          '#2196f3',
          '#3f51b5',
          '#673ab7',
          '#9c27b0',
          '#e91e63',*/
          '#f44336'
        ];
        
        var unusedColors = [
          '#795548',
          '#ff5722',
          '#ff9800',
          '#ffc107',
          //'--paper-yellow-500', this is kinda hard to see
          '#cddc39',
          '#8bc34a',
          '#009688',
          '#00bcd4',
          '#03a9f4',
          '#2196f3',
          '#3f51b5',
          '#673ab7',
          '#9c27b0',
          '#e91e63',
          '#f44336'
        ];
        var colorMap = {};
        
        var vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature, resolution) {
              var zone = feature.getProperties().speaker.zone.name;
                if(!(zone in colorMap)) {
                  var color;
                  if(unusedColors.length > 0) {
                    var index = Math.floor(Math.random() * unusedColors.length)
                    color = unusedColors[index]
                    unusedColors.splice(index, 1);
                  } else {
                    color = colors[Math.floor(Math.random() * colors.length)]
                  }

                  colorMap[zone] = color;
                }
                if(!(zone in style) || style[zone].resolution !== resolution) {
                  style[zone] = {};
                  style[zone].style = 
                  [new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 15/Math.max(resolution,1),
                            stroke: new ol.style.Stroke({
                                color: '#000000'
                            }),
                            fill: new ol.style.Fill({
                                color: colorMap[zone]
                            })
                        })
                    })];
                  /*
                    image: new ol.Overlay({
                                id: id,
                                element: elem,
                                position: coordinates,
                                positioning: 'center-center'
                              });*/
                    style[zone].resolution = resolution;
                }
                return style[zone].style;
            }
        });

        map = new ol.Map({
          layers: [
            new ol.layer.Image({
              source: new ol.source.ImageStatic({
                url: '/css/map.png',
                projection: projection,
                imageExtent: extent
              })
            }),
              vectorLayer
          ],
          overlays: [overlay],
          target: 'pagingMapContainer',
          view: new ol.View({
            projection: projection,
            center: ol.extent.getCenter(extent),
            zoom: 2
          })
        });

        /*var coordsArray = [];
        for(var i = 0; i < features.length; i++) {
          coordsArray += features[i].getGeometry().getCoordinates();

          console.log(features[i].getGeometry().getCoordinates());
        }
        map.addOverlay(pulsateCircle(coordsArray));
        */
        mapController.map = map;

        // this is the selection handler for the box dragging

        // we need to add a button if it is a touch screen
        var box = new ol.interaction.Select();
        //map.addInteraction(box);

        var selectedFeatures = box.getFeatures();

        // a DragBox interaction used to select features by drawing boxes
        var dragBox = new ol.interaction.DragBox({
          condition: ol.events.condition.shiftKeyOnly,
          style: new ol.style.Style({
            stroke: new ol.style.Stroke({
              color: [63, 81, 181, 1]
            })
          })
        });

        //map.addInteraction(dragBox);

        dragBox.on('boxend', function(e) {
          // features that intersect the box are added to the collection of
          // selected features, and their names are displayed in the "info"
          // div
          var info = [];
          var extent = dragBox.getGeometry().getExtent();

          console.log(extent);

          vectorSource.forEachFeatureIntersectingExtent(extent, function(feature) {
            console.log(feature);
            selectedFeatures.push(feature);

            // just make it grab every other one
            info.push(feature.B.speaker.id);
          });
          console.log("selectedFeatures: ", selectedFeatures);

          // To make sure that we are no running this on times when nothing is selected
          if (info.length > 0) {
             //infoBox.innerHTML = info.join(', ');
            console.log("Selected speakers: ", info);

            // i have a feeling that this is not very optimized

            // Here we figure out what is not already in the total selected and add the ones that aren't and delete it if they are
            for (var i = 0; i < info.length; i++) {
              var areYouInThere = totalInfo.indexOf(info[i]);
              if(areYouInThere == -1) {
                totalInfo.push(info[i]); 
                console.log(totalInfo);
              } else {
                console.log("Speaker", info[i], "is already in the list of selected speakers.");
                delete totalInfo[areYouInThere];    // make something for delete

                console.log(totalInfo);
              }
            }

            console.log("Total selected speakers: ", totalInfo);
            // make this a checkbox thing that will fire when checked, which means we need to keep track of two arrays?
            
            console.log("Starting sort: ");
            // Sort the array so that when we display it, the items are sorted
            totalInfo = mergeSort(totalInfo);   // This mergeSort isn't any faster wtf

            // Clear the speaker holder element and then reset the entities to everything that has been selected, updating the view if you will
            pagingSpeakerHolder = document.getElementById("pagingSpeakerHolder");
            var innerHTML = "";
            pagingSpeakerHolder.innerHTML = "";
            for (var k = 0; k < totalInfo.length; k++) {
              // The selections in the total selection array take a value of 'undefined' when deleted, and we don't want those in our view, so we parse them out
              if (totalInfo[k] !== undefined) {
               innerHTML += "<paper-item center-justified flex style=\"border-style: solid; border-radius: 5px; border-width: 1px; border-color: #3f51b5; margin: 5px;\"> Speaker " + totalInfo[k] + "</paper-item>";
                //Polymer.dom(speakerHolder).innerHTML = Polymer.dom(speakerHolder).innerHTML + "<paper-item center-justified flex style=\"border-style: solid; border-radius: 5px; border-width: 1px; border-color: #3f51b5; margin: 5px;\"> Speaker " + totalInfo[k] + "</paper-item>";/* + document.getElementById("speakerHolder").innerHTML + "<paper-item> Speaker " + totalInfo[k] + "</paper-item>" +document.getElementById("speakerHolder").innerHTML + "<paper-item> Speaker " + totalInfo[k] + "</paper-item>" +document.getElementById("speakerHolder").innerHTML + "<paper-item> Speaker " + totalInfo[k] + "</paper-item>" +document.getElementById("speakerHolder").innerHTML + "<paper-item> Speaker " + totalInfo[k] + "</paper-item>" +document.getElementById("speakerHolder").innerHTML + "<paper-item> Speaker " + totalInfo[k] + "</paper-item>" +document.getElementById("speakerHolder").innerHTML + "<paper-item> Speaker " + totalInfo[k] + "</paper-item>" +document.getElementById("speakerHolder").innerHTML + "<paper-item> Speaker " + totalInfo[k] + "</paper-item>" +document.getElementById("speakerHolder").innerHTML + "<paper-item> Speaker " + totalInfo[k];*/

                // when we send it off make a new array and splice out the undefineds 
              }
            }
            pagingSpeakerHolder.innerHTML = innerHTML;
            console.log(totalInfo);
          }
        });

        // clear selection when drawing a new box and when clicking on the map
        dragBox.on('boxstart', function(e) {

          // make something that removes them from the animation here when you feel like it

          //selectedFeatures.clear();
          //infoBox.innerHTML = '&nbsp;';
        });
        map.on('click', function() {

          console.log(selectedFeatures);
          selectedFeatures.clear();
          //infoBox.innerHTML = '&nbsp;';
        });

        // this is the selection for the tooltip shit

       /* var select = new ol.interaction.Select({
          style: function(feature, resolution) {
                var zone = feature.getProperties().speaker.zone.name;
                return style[zone].style;
            }
        });
        map.addInteraction(select);
        select.on('select', function(e) {
            if(e.selected.length > 0) {
              var speaker = e.selected[0].getProperties().speaker

              mapController.selected = speaker;
              // get the point's coordinate
              var coordinate = e.selected[0].getProperties().geometry.getCoordinates();
              overlay.setPosition(coordinate);
            } else {
              // make sure the overlay is hidden
              mapController._hideOverlay();
            }
            
        }); */
      }
    });

    function mergeSort(arr) {
        if (arr.length < 2)
            return arr;

        var middle = parseInt(arr.length / 2);
        var left   = arr.slice(0, middle);
        var right  = arr.slice(middle, arr.length);

        return merge(mergeSort(left), mergeSort(right));
    }

    function merge(left, right) {
        var result = [];

        while (left.length && right.length) {
            if (left[0] <= right[0]) {
                result.push(left.shift());
            } else {
                result.push(right.shift());
            }
        }

        while (left.length)
            result.push(left.shift());

        while (right.length)
            result.push(right.shift());

        return result;
    }
  </script>
</dom-module> 