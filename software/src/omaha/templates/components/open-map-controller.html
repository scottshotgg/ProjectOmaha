<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="/bower_components/iron-flex-layout/classes/iron-flex-layout.html">
<link rel="import" href="/bower_components/iron-icons/image-icons.html">
<link rel="import" href="/bower_components/iron-icons/av-icons.html">
<link rel="import" href="/bower_components/paper-card/paper-card.html">
<link rel="import" href="/bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/bower_components/paper-slider/paper-slider.html">
<link rel="import" href="/bower_components/paper-toast/paper-toast.html">
<link rel="import" href="/bower_components/paper-button/paper-button.html">
<link rel="import" href="/bower_components/paper-styles/paper-styles.html">
<link rel="import" href="/bower_components/neon-animation/neon-animation.html">

<link rel="import" href="/components/speaker-icon.html">
<link rel="import" href="/components/help-panel.html">
<link rel="import" href="/components/speaker-tooltip.html">
<link rel="import" href="/components/target-selector.html">
<link rel="import" href="/components/scheduling-controller.html">
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon"/ >

<link rel="stylesheet" href="jquery-ui-1.11.4.css">
<script src="jquery-1.10.2.js" type="text/jscript"></script>
<!--<script src="jquery-2.2.0.js"></script>-->
<script src="jquery-ui-1.11.4.js" type="text/jscript"></script>
<script src="jquery.ui.touch-punch.js" type="text/jscript"></script>

<dom-module id="open-map-controller">
  <template>
    <style>
      :host {
        display: block;
      }

      #map {
        height: 100%;
        width: 100%;
      }
      paper-card {
        padding: 10px;
      }
      paper-button {
        background-color: #3f51b5;
        color: #fff;
        margin-top: 5px;
        width: 100%;
      }
      #test {
        margin-left: 10px;
      }
    </style>


    <div id="mapContainer" style="width: 92%; height: 100%; float: left; visibility: visible;">
      <div id="map" class="map"></div>
    </div>

    <div id="selectedSpeakers" style="border-left: 2px solid #3f51b5; margin-left: 92%; min-width: 154px; height: 100%;">
      
      <div id="goodCircle" style="visibility: visible; background: #27e833; position: absolute; top: calc(.0075 * 100vw); border-radius: 1000px; margin-left: calc(.0075 * 100vw); margin-bottom: calc(.015 * 100vw); height: calc(.12 * 100vh); width: calc(.12 * 100vh);"></div> 
      <div id="badCircle" style="visibility: hidden; background: #f9152f; position: absolute; top: calc(.0075 * 100vw); border-radius: 1000px; margin-left: calc(.0075 * 100vw); margin-bottom: calc(.015 * 100vw); height: calc(.12 * 100vh); width: calc(.12 * 100vh);"></div>
      <div id="statusFont" style="position: absolute;  margin-left: calc(.014 * 100vw); top: calc(.085 * 100vw);"><font style="font-size: 24px;"> SYSTEM STATUS: </font>
      <div id="goodFont" style="visibility: visible; position: absolute;  margin-left: calc(.0075 * 100vw);"> <font color="#27e833" style="font-size: 24px;">GOOD</font></div>
      <div id="badFont" style="visibility: hidden; position: absolute;  margin-left: calc(.0115 * 100vw);"> <font color="#f9152f" style="font-size: 24px;">BAD</font></div>

    </div>
    
    <paper-card id="popup">  
      <speaker-tooltip id="speaker-tooltip" on-speakerselected="_selectSpeaker" on-zoneselected="_selectZone" speaker="{{selected}}"></speaker-tooltip>
    </paper-card>

    <paper-card id="test">
      <div>Status: Broken :(</div>
    </paper-card>
    <!-- <help-panel></help-panel> -->

    <iron-ajax
          id="frontendSpeakerUpdateAjax"
          url="/system/backtofront/"
          method="POST"
          content-type="application/json"
          handle-as="json"
          on-response="_logResponse"
          debounce-duration="300">
    </iron-ajax>

  </template>
  <script>

  var LowerThreshold = [];
  var UpperThreshold = [];

  $(document).ready(function() {
    console.log($(document.getElementById("goodOrBadFont")).innerWidth(), $(document.getElementById("selectedSpeakers")).innerWidth());
  });

  // center this stuff based on their size

  var savedResolution;
  var savedStyle = [];
  var savedStyle_i = 1;

  var controllers = []; 
  var renderMapCopy;
  var vectorLayerCopy;
  var goodCircle = document.getElementById("goodCircle");
  var goodFont = document.getElementById("goodFont"); 
  var badCircle = document.getElementById("badCircle");
  var badFont = document.getElementById("badFont"); 

    Polymer({
      is: 'open-map-controller',

      behaviors: [
        Polymer.NeonAnimatableBehavior
      ],

      properties: {
        animationConfig: {
          value: function() {
            return {
              'entry': {
                  name: 'fade-in-animation',
                  node: this
                },
              'exit': {
                // provided by neon-animation-animations/fade-out-animation.html
                name: 'slide-left-animation',
                node: this
              }
            }
          }
        }
      },
      
      _selectSpeaker: function() {
        this._hideOverlay();

        console.log("i am fired");

        //var coordinate = e.selected[0].getProperties().geometry.getCoordinates();
        // here is where we should pass it to the backend i think and quickly get the information
        // this is working
           /* console.log(this.$, "this is in the thing that you added")
            //if(this.isReady) {
              console.log("I am in the open-map-controller and am ready")
              var updatedAttributes = ["speaker"];
              var attributeValues = {
                "volume": this.volumeLevel,
              };
              this.$.frontendSpeakerUpdateAjax.body = {
                "updatedAttributes": updatedAttributes, 
                "attributeValues": attributeValues,
                "speaker": this.speakerId
              };
              this.$.frontendSpeakerUpdateAjax.generateRequest();
           // }*/
      },
      
      _selectZone: function() {
        this._hideOverlay();
      },
      
      _hideOverlay: function() {
        //this.overlay.setPosition([this.overlay.B.position[0] + 50, this.overlay.B.position[1] + 50]);
        console.log(this.overlay);
        //this.overlay.hide();
        //this.overlay.setPosition(undefined);
      },

      _logResponse: function(event, data) {
        console.log(data.response);
        var a = document.getElementById('speaker-tooltip');   // I guess I'll just keep this as 'a'
  
        a.speaker.name = data.response.name;
        a.speaker.VolumeLevel[0] = data.response.volume;
        a.speaker.VolumeLevel[1] = data.response.music;
        a.speaker.VolumeLevel[2] = data.response.paging;
        a.speaker.VolumeLevel[3] = data.response.masking;

        a.speaker.LowerThreshold = [];
        a.speaker.UpperThreshold = [];

        a.speaker.LowerThreshold[0] = data.response.lowerMusicThreshold
        a.speaker.UpperThreshold[0] = data.response.upperMusicThreshold
        a.speaker.LowerThreshold[1] = data.response.lowerPagingThreshold
        a.speaker.UpperThreshold[1] = data.response.upperPagingThreshold
        a.speaker.LowerThreshold[2] = data.response.lowerMaskingThreshold
        a.speaker.UpperThreshold[2] = data.response.upperMaskingThreshold

        LowerThreshold[0] = data.response.lowerMusicThreshold
        UpperThreshold[0] = data.response.upperMusicThreshold
        LowerThreshold[1] = data.response.lowerPagingThreshold
        UpperThreshold[1] = data.response.upperPagingThreshold
        LowerThreshold[2] = data.response.lowerMaskingThreshold
        UpperThreshold[2] = data.response.upperMaskingThreshold

        a.speaker.Effectiveness = data.response.effectiveness;
        a.speaker.Pleasantness = data.response.pleasantness;
        a.speaker.FadeTime = data.response.fadetime;
        a.speaker.FadeLevel = data.response.fadelevel;
        a.speaker.EqualizerMode = data.response.equalizerMode;
        a.speaker.SchedulingMode = data.response.schedulingMode;

        if(a.speaker.EqualizerMode == 1) {
          equalizerSelector.selected = "music";
          lastEQMode = "music";
          getValues();
          musicMenu.style.visibility = "visible";
          equalizerMenu.style.visibility = "hidden";
        } else if(a.speaker.EqualizerMode == 2) {
          equalizerSelector.selected = "paging"; 
          lastEQMode = "paging";
          getValues();
          //musicMenu.style.visibility = "visible";
          //equalizerMenu.style.visibility = "hidden";
          // add one for paging menu here if we need it
        }
        console.log(schedulingSelector);

        if(a.speaker.SchedulingMode == 0) {
          schedulingSelector.selected = "basic";
          drawBasic();
        } else {
          schedulingSelector.selected = "advanced";
          drawAdvanced();
        }

        console.log("i have applied the selected value", schedulingSelector.selected, schedulingSelector);

        // Setting speaker-tooltip information
        // the zones will need to be joined by ", "
        console.log(this.$$);
        if(a.speaker.name !== "") {
          var tooltipInformation = "<b id=\"name\">" + a.speaker.name + "</b><br><b id=\"speaker\">Speaker ID: " + a.speaker.id + "</b><br><b id=\"zone\">Zone ID: " + a.speaker.zoneID + "</b><br><b id=\"volume\">Volume: " + a.speaker.VolumeLevel[0] + "</b>";
          console.log("i am here");
        } else {
          console.log("i am not here");
          var tooltipInformation = "<b id=\"speaker\">Speaker ID: " + a.speaker.id + "</b><br><b id=\"zone\">Zone ID: " + a.speaker.zone.zoneID + "</b><br><b id=\"volume\">Volume: " + a.speaker.VolumeLevel[0] + "</b>";
        }
        document.getElementById("tooltipInformation").innerHTML = tooltipInformation;

        console.log("Response:", data.response);
        console.log("Speaker:", a.speaker);

        a.speaker.TargetNames   = [];
        a.speaker.CurrentTarget = [];

        a.speaker.PresetNames   = [];
        a.speaker.CurrentPreset = [];

        a.speaker.MusicPresetNames   = [];
        a.speaker.CurrentMusicPreset = [];

        a.speaker.PagingPresetNames   = [];
        a.speaker.CurrentPagingPreset = [];

        a.speaker.Target        = [];
        a.speaker.Equalizer     = [];

        a.speaker.Music         = [];

        for (i in data.response.TargetNames) {
          a.speaker.TargetNames[i] = data.response.TargetNames[i].replace("\n", "");
          console.log(i, data.response.TargetNames[i]);
        }

        for (i in data.response.PresetNames) {
          a.speaker.PresetNames[i] = data.response.PresetNames[i].replace("\n", "");
          console.log(i, data.response.PresetNames[i]);
        }

        for (i in data.response.MusicPresetNames) {
          a.speaker.MusicPresetNames[i] = data.response.MusicPresetNames[i].replace("\n", "");
          console.log(i, data.response.MusicPresetNames[i]);
        }

        for (i in data.response.PagingPresetNames) {
          a.speaker.PagingPresetNames[i] = data.response.PagingPresetNames[i].replace("\n", "");
          console.log(i, data.response.PagingPresetNames[i]);
        }

        for (i in data.response.CurrentPreset) {
          a.speaker.CurrentPreset[i] = data.response.CurrentPreset[i];
          console.log(i, data.response.CurrentPreset[i]);
        }

        for (i in data.response.CurrentMusicPreset) {
          a.speaker.CurrentMusicPreset[i] = data.response.CurrentMusicPreset[i];
          console.log(i, data.response.CurrentMusicPreset[i]);
        } 

        for (i in data.response.CurrentPagingPreset) {
          a.speaker.CurrentPagingPreset[i] = data.response.CurrentPagingPreset[i];
          console.log(i, data.response.CurrentPagingPreset[i]);
        } 

        for (i in data.response.CurrentTarget) {
          a.speaker.CurrentTarget[i] = data.response.CurrentTarget[i];
          console.log(i, data.response.CurrentTarget[i]);
          //dataArray.push(data.response.CurrentTarget[i]);
          dataArray[i] = a.speaker.CurrentTarget[i];
        }


        $(document.getElementsByClassName("inputs")).each(function(j) {
          this.value = dataArray[j];
        });
        //document.getElementById("targetListbox").selected = "Currently Applied";
        //document.getElementById("equalizerListbox").selected = "Currently Applied";
        redrawOnInput();

        dataArray = [];

        //console.log(dataArray);

        for(i in data.response.Equalizer) {
          a.speaker.Equalizer[i] = data.response.Equalizer[i];
          console.log(data.response.PresetNames[i], data.response.Equalizer[i]);
        }

        for(i in data.response.MusicEqualizer) {
          a.speaker.MusicEqualizer[i] = data.response.MusicEqualizer[i];
          console.log(data.response.MusicPresetNames[i], data.response.MusicEqualizer[i]);
        }

        for(i in data.response.PagingEqualizer) {
          a.speaker.PagingEqualizer[i] = data.response.PagingEqualizer[i];
          console.log(data.response.PagingPresetNames[i], data.response.PagingEqualizer[i]);
        }

        for(i in data.response.Target) {
          a.speaker.Target[i] = data.response.Target[i];
          console.log(data.response.TargetNames[i], data.response.Target[i]);
        }

        a.speaker.Response = "true";

        console.log("Speaker", a.speaker);
        //speaker.volumeLevel = data.response.volume;
        //console.log(speaker.volumeLevel);
      },
    
      renderMap: function() {
        var mapController = this;
        var container = document.getElementById('popup');
        var overlay = new ol.Overlay(/** @type {olx.OverlayOptions} */ ({
          element: container,
          autoPan: true,
          autoPanAnimation: {
            duration: 250
          }
        }));
        
        var tt = document.getElementById('test');
        var tooltip = new ol.Overlay(/** @type {olx.OverlayOptions} */ ({
          element: tt,
          autoPan: true,
          autoPanAnimation: {
            duration: 250
          }
        }));
        
        mapController.overlay = overlay;
        
        // Map views always need a projection.  Here we just want to map image
        // coordinates directly to map coordinates, so we create a projection that uses
        // the image extent in pixels.
        var extent = [0, 0, 2200, 1700];        // this needs to read in the coordinates from the image itself
        var projection = new ol.proj.Projection({
          code: 'pixel',
          units: 'pixels',
          extent: extent
        });

        var locations = this.controllers;
        controllers = this.controllers;

        var features = new Array(locations.length);
        for(var i = 0; i < features.length; i++) {
            var coordinates = [locations[i].x, 1700-locations[i].y];
            var point = new ol.geom.Point(coordinates);
            features[i] = new ol.Feature({
              geometry: point,
              speaker: locations[i]
            });
        }
        
        var vectorSource = new ol.source.Vector({
            features: features
        });

        var style = {}
        var allColors = [
          /*'#795548',
          '#ff5722',
          '#ff9800',
          '#ffc107',
          //'--paper-yellow-500', this is kinda hard to see
          '#cddc39',
          '#8bc34a',
          '#009688',
          '#00bcd4',
          '#03a9f4',
          '#2196f3',
          '#3f51b5',
          '#673ab7',
          '#9c27b0',
          '#e91e63',
          '#f44336'*/
          '#3f51b5'
        ];
        
        var unusedColors = [
          '#795548',
          '#ff5722',
          '#ff9800',
          '#ffc107',
          //'--paper-yellow-500', this is kinda hard to see
          '#cddc39',
          '#8bc34a',
          '#009688',
          '#00bcd4',
          '#03a9f4',
          '#2196f3',
          '#3f51b5',
          '#673ab7',
          '#9c27b0',
          '#e91e63',
          '#f44336',
          '#3f51b5'
        ];
        var colorMap = {};
        var vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature, resolution) {
              var zone = feature.getProperties().speaker.zone.name;
              if(!(zone in colorMap)) {
                var color;
                if(unusedColors.length > 0) {
                  var index = Math.floor(Math.random() * unusedColors.length)
                  color = unusedColors[index]
                  unusedColors.splice(index, 1);
                } else {
                  color = colors[Math.floor(Math.random() * colors.length)]
                }

                colorMap[zone] = color;
                savedStyle[zone] = color;
                savedStyle_i++;
                console.log(savedStyle);
              }
              if(!(zone in style) || style[zone].resolution !== resolution) {
                style[zone] = {};
                style[zone].style = [new ol.style.Style({
                    image: new ol.style.Circle({
                      radius: 15/Math.max(resolution, 1),
                      stroke: new ol.style.Stroke({
                          color: '#000000'
                      }),
                      fill: new ol.style.Fill({
                          color: colorMap[zone]
                      })
                    })
                })];
                style[zone].resolution = resolution;
              }

              savedResolution = resolution;
              savedFeature = feature;

              //console.log(feature.getProperties().speaker);

              var errorStyle = new ol.style.Style({
                image: new ol.style.Icon({
                  src: "/css/brokenlink.png"
                })
              });

              if(zone == "default") {
                //console.log("I AM IN");
                var speakers = feature.getProperties().speaker;
                //for(i in speakers) {       // this can be improved
                  //console.log(speakers.status);

                  //console.log(feature.geometry);
                  if(speakers.status !== 0) {
                    console.log("updateMapForError", speakers.id);
                    //updateMapForError(i, true);

                    feature.setStyle(errorStyle);
                  }
                //}
              }
              return style[zone].style;
            }
        });

        vectorLayerCopy = vectorLayer;

        var map = new ol.Map({
          layers: [
            new ol.layer.Image({
              source: new ol.source.ImageStatic({
                url: '/css/map.png',
                projection: projection,
                imageExtent: extent
              })
            }),
              vectorLayer
          ],
          overlays: [overlay, tooltip],
          target: 'map',
          view: new ol.View({
            projection: projection,
            center: ol.extent.getCenter(extent),
            zoom: 2
          })
        });
        mapController.map = map;

        var select = new ol.interaction.Select({
          style: function(feature, resolution) {
                var zone = feature.getProperties().speaker.zone.name;
                return style[zone].style;
            }
        });


        map.addInteraction(select);

        select.on('select', function(e) {
            if(e.selected.length > 0) {
              console.log("Selected");
              var speaker = e.selected[0].getProperties().speaker
              console.log(e)
              console.log(speaker);

              var frontendSpeakerUpdateAjax = document.getElementById("frontendSpeakerUpdateAjax");
              console.log("If I do say myself sir, this is a pretty snazzy way to go about doing this!");
              frontendSpeakerUpdateAjax.body = {
                "speaker": speaker.id
              };
              console.log("frontendSpeakerUpdateAjax ", frontendSpeakerUpdateAjax.body);
              frontendSpeakerUpdateAjax.generateRequest(); 

              mapController.selected = speaker;
              // get the point's coordinate
              var coordinate = e.selected[0].getProperties().geometry.getCoordinates();

              console.log(coordinate)

              console.log(speaker);

              overlay.setPosition(coordinate);

              console.log(colorMap);
            } else {
              // make sure the overlay is hidden
              mapController._hideOverlay();
            }
        });
        
        var hoverInteraction = new ol.interaction.Select({
            condition: ol.events.condition.pointerMove,
            style: function(feature, resolution) {
                return style.style;
            }
        });
        //map.addInteraction(hoverInteraction);
        hoverInteraction.on('select', function(e){
          if(e.selected.length > 0) {
              console.log("Selected");
              var speaker = e.selected[0].getProperties().speaker;
              console.log(speaker);
              var coordinate = e.selected[0].getProperties().geometry.getCoordinates();
              tooltip.setPosition(coordinate);
            }
        })
      }
    });

  function updateMapForError(id, change) {

    // console.log(change);

    // /change = false;

    var features = vectorLayerCopy.getSource().getFeatures();
    var i = 0;
    for(i = 0; i < features.length; i++) {
      if(features[i].getProperties().speaker.id == id) {
        console.log(features[i].getProperties().speaker);
        break;
      }
    }

    console.log("i: ", i);
    console.log("features of i", features[i].getProperties().speaker);

    var old_style = features[i].getStyle(style);

    console.log(features);


    /*if(change === false) {
      features[i].setStyle(old_style);
      vectorLayerCopy.changed();
    } else {

      // this may need a scale applied to it for the zooming
      

      //console.log(features.style);

      //document.querySelector("open-map-controller").renderMap();
    }*/
    var style;

    if(change) {
      style = new ol.style.Style({
        image: new ol.style.Icon({
          src: "/css/brokenlink.png"
        })
      });
      console.log(statusCircle);

      // update the system status icon
      goodCircle.style.visibility = "hidden";
      badCircle.style.visibility = "visibility";
      goodFont.style.visibility = "hidden";
      badFont.style.visibility = "visibility";

      // we also need to add something to track which speakers are fine and which ones arent so that we
      // can do instant updating

      // this thing also needs to remove the possibility to communicate with the speaker, remove the pop-up

    } else {
       style = new ol.style.Style({
                    image: new ol.style.Circle({
                      radius: 15/Math.max(savedResolution, 1),
                      stroke: new ol.style.Stroke({
                          color: '#000000'
                      }),
                      fill: new ol.style.Fill({
                          color: savedStyle[features[i].getProperties().speaker.zone.name]
                      })
                    })
                });

       // update the statuscircle thing
    }

    features[i].setStyle(style);
    vectorLayerCopy.changed();
  }

  </script>
</dom-module>